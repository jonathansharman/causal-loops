import Graphics2D;
import TwoCansAlpha4;

// An object in a level.
class Object {
	// The level this object is in.
	field level;
	// Row-column position.
	field position;

	constructor(level, position) {
		this.level = level;
		this.position = position;
	}

	// Pushes this object towards "direction", along with anything in the way, if "strength" >= # of objects to push.
	function push(direction, strength = 2) {
		// Can't push anything with zero strength.
		if (strength == 0) return false;

		// Get neighboring position.
		neighborPosition = this.level.neighbor(this.position, direction);

		// Push neighbor, if any.
		neighbor = this.level.objects[neighborPosition[0]][neighborPosition[1]];
		if (neighbor != null && !neighbor.push(direction, strength - 1)) {
			// Too much stuff in the way.
			return false;
		}

		// Try to push this.
		currentTile = this.level.tiles[this.position[0]][this.position[1]];
		neighborTile = this.level.tiles[neighborPosition[0]][neighborPosition[1]];
		if (neighborTile.acceptFrom(this, direction)) {
			currentTile.evictTowards(this, direction);
			return true;
		} else {
			return false;
		}
	}

	function enterFloor(floor, direction) {
		this.level.objects[floor.position[0]][floor.position[1]] = this;
		this.position = floor.position;
		return true;
	}

	function enterWall(floor, direction) {
		return false;
	}

	function enterIce(floor, direction) {
		this.level.objects[floor.position[0]][floor.position[1]] = this;
		this.position = floor.position;
		if (direction != null) {
			this.push(direction);
		}
		return true;
	}

	function enterStairs(floor, direction) {
		this.level.objects[floor.position[0]][floor.position[1]] = this;
		this.position = floor.position;
		return true;
	}
}

// A player-controllable character.
class Character : Object {
	field direction = Direction.DOWN;
	field returnPoint = null;
	field inLevel = true;

	constructor(level, position) : base(level, position) {}

	function draw() {
		switch (this.direction) {
			case Direction.UP:
				image = Images.get("images/character-up.png");
				break;
			case Direction.DOWN:
				image = Images.get("images/character-down.png");
				break;
			case Direction.LEFT:
				image = Images.get("images/character-left.png");
				break;
			case Direction.RIGHT:
				image = Images.get("images/character-right.png");
				break;
		}
		xy = this.level.rowColToXY(this.position[0], this.position[1]);
		image.draw(xy[0], xy[1]);
	}

	function removeFromLevel() {
		for (i = 0; i < this.level.characters.length; ++i) {
			if (this.level.characters[i] == this) {
				this.level.objects[this.position[0]][this.position[1]] = null;
				this.level.characters.remove(i);
				if (this.level.characterIdx > i) {
					--this.level.characterIdx;
				}
				this.inLevel = false;
				return;
			}
		}
	}

	// Whether this character can summon itself from the future at the given row-column position.
	function canSummonAt(position) {
		// Can't summon more than one version of a character from the future at a time.
		if (this.returnPoint != null) {
			return false;
		}

		// Can't summon out of bounds.
		if (position[0] < 0 || position[0] >= this.level.rowCount || position[1] < 0 || position[1] >= this.level.colCount) {
			return false;
		}

		// Can't summon into certain tiles.
		tile = this.level.tiles[position[0]][position[1]];
		if (tile != null && !tile.isValidSummonTarget()) {
			return false;
		}

		// Can't summon onto other objects.
		if (this.level.objects[position[0]][position[1]] != null) {
			return false;
		}

		return true;
	}

	// Summons the current character from the future at the given target position.
	function summonFromFuture(position) {
		if (!this.canSummonAt(position)) {
			return;
		}

		// Create future character.
		futureCharacter = new Character(this.level, position.clone());
		// Add the new character after the current character.
		this.level.characters.insert(this.level.characterIdx + 1, futureCharacter);
		++this.level.characterCount;
		// Put new character into the level.
		this.level.tiles[position[0]][position[1]].acceptFrom(futureCharacter, null);
		// Create a return point where the future character came from.
		returnPoint = new ReturnPoint(this.level, position.clone(), 20, this);
		// Set the current character as the character who needs to return to the return point.
		this.returnPoint = returnPoint;
		// Andvance time.
		this.level.advanceTime();
		// Add the return point to the list after advancing time so it starts at max time.
		this.level.returnPoints.add(returnPoint);
	}

	function enterStairs(floor, direction) {
		this.position = floor.position;
		this.removeFromLevel();
		--this.level.characterCount;
		return true;
	}

	function enterHole(floor, direction) {
		this.removeFromLevel();
		this.position = floor.position;
		this.level.tiles[floor.position[0]][floor.position[1]] = new TrappedCharacter(this.level, floor.position);
		return true;
	}
}

// A pushable crate.
class Crate : Object {
	constructor(level, position) : base(level, position) {}

	function draw() {
		xy = this.level.rowColToXY(this.position[0], this.position[1]);
		Images.get("images/crate.png").draw(xy[0], xy[1]);
	}

	function enterHole(floor, direction) {
		this.level.tiles[floor.position[0]][floor.position[1]] = new SunkenCrate(this.level, floor.position);
		return true;
	}
}

// A pushable, slidable block of ice.
class IceBlock : Object {
	constructor(level, position) : base(level, position) {}

	function draw() {
		xy = this.level.rowColToXY(this.position[0], this.position[1]);
		Images.get("images/ice-block.png").draw(xy[0], xy[1]);
	}

	function enterFloor(floor, direction) {
		this.level.objects[floor.position[0]][floor.position[1]] = this;
		this.position = floor.position;
		this.push(direction, 1);
		return true;
	}

	function enterIce(floor, direction) {
		this.level.objects[floor.position[0]][floor.position[1]] = this;
		this.position = floor.position;
		this.push(direction, 1);
		return true;
	}

	function enterHole(floor, direction) {
		this.level.tiles[floor.position[0]][floor.position[1]] = new Ice(this.level, floor.position);
		return true;
	}
}
