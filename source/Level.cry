import Graphics2D;
import Math;
import Random;
import Resources;
import TwoCansAlpha4;

const TILE_SIZE = 20;
const MAX_COL_COUNT = X_RES / TILE_SIZE;
const MAX_ROW_COUNT = Y_RES / TILE_SIZE;

const MIN_SUMMON_TIME = 1;
const DFLT_SUMMON_TIME = 20;
const MAX_SUMMON_TIME = 99;
const SUMMON_TIME_STEP = 10;

// Represents a game level and its current state.
class Level {
	field rowCount;
	field colCount;

	field xMargin;
	field yMargin;

	field tiles;

	field objects;

	field characters;
	field characterIdx = 0;
	field characterCount = 0;

	field returnPoints;

	field doors = [0, 0, 0];

	// Whether the level's state is logically consistent.
	field consistent = true;

	field summoning = false;
	field summonTime;
	field mousePosition;

	// Loads the level from file.
	constructor(filename) {
		this.rowCount = 0;
		this.colCount = 0;
		this.tiles = [[]];
		this.objects = [[]];
		this.characters = [];
		this.returnPoints = [];

		levelText = Resources.readText(filename);
		row = 0;
		col = 0;
		idx = 0;
		while (idx < levelText.length) {
			// Get tile.
			switch (levelText[idx]) {
				case "-":
					this.tiles[row].add(new Blank(this, [row, col]));
					break;
				case ".":
					this.tiles[row].add(new Floor(this, [row, col]));
					break;
				case "#":
					this.tiles[row].add(new Wall(this, [row, col]));
					break;
				case "/":
					this.tiles[row].add(new Ice(this, [row, col]));
					break;
				case ">":
					this.tiles[row].add(new Stairs(this, [row, col]));
					break;
				case "O":
					this.tiles[row].add(new Hole(this, [row, col]));
					break;
				case "r":
					this.tiles[row].add(new PressureSwitch(0, this, [row, col]));
					++this.doors[0];
					break;
				case "R":
					this.tiles[row].add(new Door(0, this, [row, col]));
					break;
				case "g":
					this.tiles[row].add(new PressureSwitch(1, this, [row, col]));
					++this.doors[1];
					break;
				case "G":
					this.tiles[row].add(new Door(1, this, [row, col]));
					break;
				case "b":
					this.tiles[row].add(new PressureSwitch(2, this, [row, col]));
					++this.doors[2];
					break;
				case "B":
					this.tiles[row].add(new Door(2, this, [row, col]));
					break;
				default:
					this.tiles.add([]);
					this.objects.add([]);
					this.rowCount = Math.max(this.rowCount, this.tiles.length);
					col = 0;
					++row;
					++idx;
					continue;
					break;
			}
			this.colCount = Math.max(this.colCount, this.tiles[row].length);
			++idx;
			// Get object, if present.
			switch (levelText[idx]) {
				case " ":
					object = null;
					break;
				case "@":
					object = new Character(this, [row, col]);
					this.characters.add(object);
					++this.characterCount;
					break;
				case "X":
					object = new Crate(this, [row, col]);
					break;
				case "*":
					object = new IceBlock(this, [row, col]);
					break;
			}
			this.objects[row].add(object);
			++idx;
			++col;
		}
		this.xMargin = (X_RES - this.colCount * TILE_SIZE) / 2;
		this.yMargin = (Y_RES - this.rowCount * TILE_SIZE) / 2;
	}

	// Gets the currently selected character or null if there are no characters left.
	function getCurrentCharacter() {
		if (this.characters.length == 0) return null;
		this.characterIdx = this.characterIdx % this.characters.length;
		return this.characters[this.characterIdx];
	}

	// Gets the position adjacent to "position", towards "direction".
	function neighbor(position, direction) {
		switch (direction) {
			case Direction.UP:
				return [(position[0] - 1) % this.rowCount, position[1]];
				break;
			case Direction.DOWN:
				return [(position[0] + 1) % this.rowCount, position[1]];
				break;
			case Direction.LEFT:
				return [position[0], (position[1] - 1) % this.colCount];
				break;
			case Direction.RIGHT:
				return [position[0], (position[1] + 1) % this.colCount];
				break;
		}
	}

	// Advances time by one turn.
	function advanceTime() {
		for (i = 0; i < this.returnPoints.length; ++i) {
			this.returnPoints[i].update();
			if (!this.consistent) {
				return;
			} else if (this.returnPoints[i].satisfied) {
				this.returnPoints.remove(i);
				--i;
			}
		}
		// Characters who wait look down.
		for (character : this.characters) {
			character.direction = Direction.DOWN;
		}
	}

	// Converts (row, col) to (x, y).
	function rowColToXY(row, col) {
		return [this.xMargin + col * TILE_SIZE, this.yMargin + row * TILE_SIZE];
	}

	// Converts (x, y) to (row, col).
	function xyToRowCol(x, y) {
		return [(y - this.yMargin) / TILE_SIZE, (x - this.xMargin) / TILE_SIZE];
	}

	// Updates the level.
	function update(inputManager, events) {
		this.summoning = inputManager.isShiftPressed();

		if (this.summoning) {
			mousePosition = inputManager.getMousePosition();
			this.mousePosition = mousePosition;
			for (e : events) {
				if (e.type == EventType.MOUSE_PRESS) {
					// Summon.
					currentCharacter = this.getCurrentCharacter();
					if (currentCharacter != null) {
						currentCharacter.summonFromFuture(this.xyToRowCol(e.x, e.y), this.summonTime);
						this.summonTime = DFLT_SUMMON_TIME;
					}
				} else if (e.type == EventType.KEY && e.down) {
					switch (e.key) {
						case KeyboardKey.UP:    ++this.summonTime;                   break;
						case KeyboardKey.DOWN:  --this.summonTime;                   break;
						case KeyboardKey.LEFT:  this.summonTime -= SUMMON_TIME_STEP; break;
						case KeyboardKey.RIGHT: this.summonTime += SUMMON_TIME_STEP; break;
						case KeyboardKey.W:     ++this.summonTime;                   break;
						case KeyboardKey.S:     --this.summonTime;                   break;
						case KeyboardKey.A:     this.summonTime -= SUMMON_TIME_STEP; break;
						case KeyboardKey.D:     this.summonTime += SUMMON_TIME_STEP; break;
						default:
							break;
					}
					this.summonTime = Math.max(MIN_SUMMON_TIME, Math.min(MAX_SUMMON_TIME, this.summonTime));
				}
			}
		} else {
			this.summonTime = DFLT_SUMMON_TIME;
			for (e : events) {
				if (e.type == EventType.KEY && e.down) {
					direction = null;
					switch (e.key) {
						case KeyboardKey.Q:
							// Previous character.
							--this.characterIdx;
							break;
						case KeyboardKey.E:
							// Next character.
							++this.characterIdx;
							break;
						case KeyboardKey.SPACE:
							// Wait.
							this.advanceTime();
							break;
						// Movement commands.
						case KeyboardKey.UP:    direction = Direction.UP;    break;
						case KeyboardKey.DOWN:  direction = Direction.DOWN;  break;
						case KeyboardKey.LEFT:  direction = Direction.LEFT;  break;
						case KeyboardKey.RIGHT: direction = Direction.RIGHT; break;
						case KeyboardKey.W:     direction = Direction.UP;    break;
						case KeyboardKey.S:     direction = Direction.DOWN;  break;
						case KeyboardKey.A:     direction = Direction.LEFT;  break;
						case KeyboardKey.D:     direction = Direction.RIGHT; break;
						default:
							break;
					}
					if (direction != null) {
						// Try to push the current character.
						currentCharacter = this.getCurrentCharacter();
						if (currentCharacter != null && currentCharacter.push(direction)) {
							// If the character moved, advance time.
							this.advanceTime();
							// Update character's direction.
							currentCharacter.direction = direction;
						}
					}
				}
			}
		}
	}

	// Draws the level to the screen.
	function draw() {
		for (row = 0; row < this.rowCount; ++row) {
			for (col = 0; col < this.colCount; ++col) {
				// Draw tiles.
				tile = this.tiles[row][col];
				if (tile != null) {
					tile.draw();
				}

				// Draw objects.
				object = this.objects[row][col];
				if (object != null) {
					object.draw();
					// Draw selector over current character if there are multiple characters.
					if (this.characters.length > 1 && object == this.getCurrentCharacter()) {
						xy = this.rowColToXY(row, col);
						Images.get("images/selector.png").draw(xy[0], xy[1]);
					}
				}
			}
		}

		// Draw return points.
		for (returnPoint : this.returnPoints) {
			returnPoint.draw();
		}

		// Draw mouse hover highlight, if summoning.
		if (this.summoning) {
			hoveredRowCol = this.xyToRowCol(this.mousePosition[0], this.mousePosition[1]);
			highlightXY = this.rowColToXY(hoveredRowCol[0], hoveredRowCol[1]);
			currentCharacter = this.getCurrentCharacter();
			highlightRGB = (currentCharacter != null && currentCharacter.canSummonAt(hoveredRowCol))
				? [255, 255, 255]
				: [255, 96, 96]
				;
			Graphics2D.Draw.rectangle
				( highlightXY[0] + 1, highlightXY[1] + 1
				, TILE_SIZE - 1, TILE_SIZE - 1
				, highlightRGB[0], highlightRGB[1], highlightRGB[2], 128
				);
			drawNumber(this.summonTime, this.mousePosition[0], this.mousePosition[1]);
		}
	}
}
