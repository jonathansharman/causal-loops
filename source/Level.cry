import Graphics2D;
import Math;
import Random;
import Resources;
import TwoCansAlpha4;

const MIN_TILE_SIZE = 20;
const MAX_COL_COUNT = X_RES / MIN_TILE_SIZE;
const MAX_ROW_COUNT = Y_RES / MIN_TILE_SIZE;

const MIN_SUMMON_TIME = 1;
const DFLT_SUMMON_TIME = 99;
const MAX_SUMMON_TIME = 99;
const SUMMON_TIME_STEP = 10;

// Represents a game level and its current state.
class Level {
	field rowCount;
	field colCount;

	field xMargin;
	field yMargin;
	field zoom;
	field tileSize;

	field tiles;

	field objects;

	field characters;
	field characterIdx = 0;
	field characterCount = 0;

	field returnPoints;

	field doors = [0, 0, 0];

	// Whether the level's state is logically consistent.
	field consistent = true;

	field summoning = false;
	field summonTime = DFLT_SUMMON_TIME;
	field mousePosition;

	// Loads the level from file.
	constructor(filename) {
		this.rowCount = 0;
		this.colCount = 0;
		this.tiles = [[]];
		this.objects = [[]];
		this.characters = [];
		this.returnPoints = [];

		levelText = Resources.readText(filename);
		row = 0;
		col = 0;
		idx = 0;
		while (idx < levelText.length) {
			// Get tile.
			switch (levelText[idx]) {
				case "-":
					this.tiles[row].add(new Blank(this, [row, col]));
					break;
				case ".":
					this.tiles[row].add(new Floor(this, [row, col]));
					break;
				case "#":
					this.tiles[row].add(new Wall(this, [row, col]));
					break;
				case "/":
					this.tiles[row].add(new Ice(this, [row, col]));
					break;
				case ">":
					this.tiles[row].add(new Stairs(this, [row, col]));
					break;
				case "O":
					this.tiles[row].add(new Hole(this, [row, col]));
					break;
				case "Z":
					this.tiles[row].add(new ElectricFloor(this, [row, col]));
					break;
				case "r":
					this.tiles[row].add(new PressureSwitch(0, this, [row, col]));
					++this.doors[0];
					break;
				case "R":
					this.tiles[row].add(new Door(0, this, [row, col]));
					break;
				case "g":
					this.tiles[row].add(new PressureSwitch(1, this, [row, col]));
					++this.doors[1];
					break;
				case "G":
					this.tiles[row].add(new Door(1, this, [row, col]));
					break;
				case "b":
					this.tiles[row].add(new PressureSwitch(2, this, [row, col]));
					++this.doors[2];
					break;
				case "B":
					this.tiles[row].add(new Door(2, this, [row, col]));
					break;
				default:
					this.tiles.add([]);
					this.objects.add([]);
					this.rowCount = Math.max(this.rowCount, this.tiles.length);
					col = 0;
					++row;
					++idx;
					continue;
					break;
			}
			this.colCount = Math.max(this.colCount, this.tiles[row].length);
			++idx;
			// Get object, if present.
			switch (levelText[idx]) {
				case " ":
					object = null;
					break;
				case "@":
					object = new Character(this, [row, col]);
					this.characters.add(object);
					++this.characterCount;
					break;
				case "X":
					object = new Crate(this, [row, col]);
					break;
				case "*":
					object = new IceBlock(this, [row, col]);
					break;
			}
			this.objects[row].add(object);
			++idx;
			++col;
		}
		minWidth = this.colCount * MIN_TILE_SIZE;
		minHeight = this.rowCount * MIN_TILE_SIZE;
		this.zoom = Math.max(1, Math.min(Math.floor(1.0 * X_RES / minWidth), Math.floor(1.0 * Y_RES / minHeight)));
		this.tileSize = MIN_TILE_SIZE * this.zoom;
		this.xMargin = (X_RES - this.colCount * this.tileSize) / 2;
		this.yMargin = (Y_RES - this.rowCount * this.tileSize) / 2;
	}

	// Gets the currently selected character or null if there are no characters left.
	function getCurrentCharacter() {
		if (this.characters.length == 0) return null;
		this.characterIdx = this.characterIdx % this.characters.length;
		return this.characters[this.characterIdx];
	}

	// Gets the row-column position adjacent to rowCol, towards direction.
	function neighbor(rowCol, direction) {
		switch (direction) {
			case Direction.UP:
				return [(rowCol[0] - 1) % this.rowCount, rowCol[1]];
				break;
			case Direction.DOWN:
				return [(rowCol[0] + 1) % this.rowCount, rowCol[1]];
				break;
			case Direction.LEFT:
				return [rowCol[0], (rowCol[1] - 1) % this.colCount];
				break;
			case Direction.RIGHT:
				return [rowCol[0], (rowCol[1] + 1) % this.colCount];
				break;
		}
	}

	// Advances time by one turn.
	function advanceTime() {
		for (i = 0; i < this.returnPoints.length; ++i) {
			this.returnPoints[i].update();
			if (!this.consistent) {
				return;
			} else if (this.returnPoints[i].satisfied) {
				this.returnPoints.remove(i);
				--i;
			}
		}
		// Characters who wait look down.
		for (character : this.characters) {
			character.direction = Direction.DOWN;
		}
	}

	// Converts (row, col) to (x, y).
	function rowColToXY(rowCol) {
		return [this.xMargin + rowCol[1] * this.tileSize, this.yMargin + rowCol[0] * this.tileSize];
	}

	// Converts (x, y) to (row, col).
	function xyToRowCol(xy) {
		return [(xy[1] - this.yMargin) / this.tileSize, (xy[0] - this.xMargin) / this.tileSize];
	}

	// Updates the level.
	function update(inputManager, events) {
		this.mousePosition = inputManager.getMousePosition();
		this.summoning = inputManager.isShiftPressed();
		if (this.summoning) {
			for (e : events) {
				if (e.type == EventType.MOUSE_PRESS) {
					// Summon.
					currentCharacter = this.getCurrentCharacter();
					if (currentCharacter != null) {
						currentCharacter.summonFromFuture(this.xyToRowCol([e.x, e.y]), this.summonTime);
					}
				} else if (e.type == EventType.KEY && e.down) {
					switch (e.key) {
						case KeyboardKey.UP:    ++this.summonTime;                   break;
						case KeyboardKey.DOWN:  --this.summonTime;                   break;
						case KeyboardKey.LEFT:  this.summonTime -= SUMMON_TIME_STEP; break;
						case KeyboardKey.RIGHT: this.summonTime += SUMMON_TIME_STEP; break;
						case KeyboardKey.W:     ++this.summonTime;                   break;
						case KeyboardKey.S:     --this.summonTime;                   break;
						case KeyboardKey.A:     this.summonTime -= SUMMON_TIME_STEP; break;
						case KeyboardKey.D:     this.summonTime += SUMMON_TIME_STEP; break;
						default:
							break;
					}
					this.summonTime = Math.max(MIN_SUMMON_TIME, Math.min(MAX_SUMMON_TIME, this.summonTime));
				}
			}
		} else {
			for (e : events) {
				if (e.type == EventType.MOUSE_PRESS) {
					// Switch to clicked character, if any.
					clickedPosition = this.xyToRowCol(this.mousePosition);
					for (i = 0; i < this.characters.length; ++i) {
						characterPosition = this.characters[i].rowCol;
						if (characterPosition[0] == clickedPosition[0] && characterPosition[1] == clickedPosition[1]) {
							this.characterIdx = i;
							break;
						}
					}
				} else if (e.type == EventType.KEY && e.down) {
					direction = null;
					switch (e.key) {
						case KeyboardKey.SPACE:
							// Try to wait until a character returns to the past.
							if (this.returnPoints.length != 0) {
								// Find the return point that will trigger next.
								idx = 0;
								for (i = 1; i < this.returnPoints.length; ++i) {
									if (this.returnPoints[i].time < this.returnPoints[idx].time) {
										idx = i;
									}
								}
								// Fast forward if the character is in position.
								retPt = this.returnPoints[idx];
								retChar = retPt.character;
								if (retPt.rowCol[0] == retChar.rowCol[0] && retPt.rowCol[1] == retChar.rowCol[1]) {
									time = retPt.time;
									for (i = 0; i < time; ++i) {
										this.advanceTime();
										if (!this.consistent) {
											return;
										}
									}
								}
							}
							break;
						case KeyboardKey.Z:
							// Wait one turn.
							this.advanceTime();
							break;
						case KeyboardKey.Q:
							// Previous character.
							--this.characterIdx;
							break;
						case KeyboardKey.E:
							// Next character.
							++this.characterIdx;
							break;
						// Movement commands.
						case KeyboardKey.UP:    direction = Direction.UP;    break;
						case KeyboardKey.DOWN:  direction = Direction.DOWN;  break;
						case KeyboardKey.LEFT:  direction = Direction.LEFT;  break;
						case KeyboardKey.RIGHT: direction = Direction.RIGHT; break;
						case KeyboardKey.W:     direction = Direction.UP;    break;
						case KeyboardKey.S:     direction = Direction.DOWN;  break;
						case KeyboardKey.A:     direction = Direction.LEFT;  break;
						case KeyboardKey.D:     direction = Direction.RIGHT; break;
						default:
							break;
					}
					if (direction != null) {
						// Try to push the current character.
						currentCharacter = this.getCurrentCharacter();
						if (currentCharacter != null) {
							currentCharacter.momentum = 2;
							if (currentCharacter.push(direction)) {
								// If the character moved, advance time.
								this.advanceTime();
								// Update character's direction.
								currentCharacter.direction = direction;
							}
						}
					}
				}
			}
		}
	}

	// Draws a 21 x 21 tile image at the given row-column position, with the given offsets (at 1 x zoom).
	function drawTile(image, rowCol, offset = [0, 0]) {
		xy = this.rowColToXY(rowCol);
		image.drawStretched
			( xy[0] + offset[0] * this.zoom
			, xy[1] + offset[1] * this.zoom
			, image.width * this.zoom
			, image.height * this.zoom
			);
	}

	// Draws a number to the upper-left of (x, y).
	function drawNumber(n, xy) {
		xyCopy = xy.clone();
		while (n > 0) {
			digit = n % 10;
			n /= 10;
			image = Images.get("images/" + digit + ".png");
			xyCopy[0] -= image.width * this.zoom;
			y_top = xyCopy[1] - image.height * this.zoom;
			image.drawStretched(xyCopy[0], y_top, image.width * this.zoom, image.height * this.zoom);
		}
	}

	// Draws the level to the screen.
	function draw() {
		for (row = 0; row < this.rowCount; ++row) {
			for (col = 0; col < this.colCount; ++col) {
				// Draw tiles.
				tile = this.tiles[row][col];
				if (tile != null) {
					tile.draw();
				}

				// Draw objects.
				object = this.objects[row][col];
				if (object != null) {
					object.draw();
				}
			}
		}

		// Draw return points.
		for (returnPoint : this.returnPoints) {
			returnPoint.draw();
		}

		// Draw mouse hover highlight, if summoning.
		if (this.summoning) {
			hoveredRowCol = this.xyToRowCol(this.mousePosition);
			highlightXY = this.rowColToXY(hoveredRowCol);
			currentCharacter = this.getCurrentCharacter();
			highlightRGB = (currentCharacter != null && currentCharacter.canSummonAt(hoveredRowCol))
				? [255, 255, 255]
				: [255, 96, 96]
				;
			Graphics2D.Draw.rectangle
				( highlightXY[0] + this.zoom, highlightXY[1] + this.zoom
				, this.tileSize - this.zoom, this.tileSize - this.zoom
				, highlightRGB[0], highlightRGB[1], highlightRGB[2], 128
				);
			this.drawNumber(this.summonTime, this.mousePosition);
		}
	}
}
