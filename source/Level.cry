import Graphics2D;
import Math;
import Random;
import Resources;
import TwoCansAlpha4;

const MIN_TILE_SIZE = 20;
const MAX_COL_COUNT = X_RES / MIN_TILE_SIZE;
const MAX_ROW_COUNT = Y_RES / MIN_TILE_SIZE;

const MIN_SUMMON_TIME = 1;
const DFLT_SUMMON_TIME = 99;
const MAX_SUMMON_TIME = 99;
const SUMMON_TIME_STEP = 10;

// Represents a game level and its current state.
class Level {
	field rowCount;
	field colCount;

	field xMargin;
	field yMargin;
	field zoom;
	field tileSize;

	field tiles;

	field objects;

	field characters;
	field characterIdx = 0;
	field characterCount = 0;

	field returnPoints;

	field doors = [0, 0, 0];

	// Whether the level's state is logically consistent.
	field consistent = true;

	field summoning = false;
	field summonTime = DFLT_SUMMON_TIME;
	field summonMouseXY;
	field summonKeyboardXY = null;

	// Loads the level from file.
	constructor(filename) {
		this.rowCount = 0;
		this.colCount = 0;
		this.tiles = [[]];
		this.objects = [[]];
		this.characters = [];
		this.returnPoints = [];

		levelText = Resources.readText(filename);
		row = 0;
		col = 0;
		idx = 0;
		while (idx < levelText.length) {
			// Get tile.
			switch (levelText[idx]) {
				case "-":
					this.tiles[row].add(new Blank(this, [row, col]));
					break;
				case ".":
					this.tiles[row].add(new Floor(this, [row, col]));
					break;
				case "#":
					this.tiles[row].add(new Wall(this, [row, col]));
					break;
				case "/":
					this.tiles[row].add(new Ice(this, [row, col]));
					break;
				case ">":
					this.tiles[row].add(new Stairs(this, [row, col]));
					break;
				case "O":
					this.tiles[row].add(new Hole(this, [row, col]));
					break;
				case "Z":
					this.tiles[row].add(new ElectricFloor(this, [row, col]));
					break;
				case "r":
					this.tiles[row].add(new PressureSwitch(0, this, [row, col]));
					++this.doors[0];
					break;
				case "R":
					this.tiles[row].add(new Door(0, this, [row, col]));
					break;
				case "g":
					this.tiles[row].add(new PressureSwitch(1, this, [row, col]));
					++this.doors[1];
					break;
				case "G":
					this.tiles[row].add(new Door(1, this, [row, col]));
					break;
				case "b":
					this.tiles[row].add(new PressureSwitch(2, this, [row, col]));
					++this.doors[2];
					break;
				case "B":
					this.tiles[row].add(new Door(2, this, [row, col]));
					break;
				default:
					this.tiles.add([]);
					this.objects.add([]);
					this.rowCount = Math.max(this.rowCount, this.tiles.length);
					col = 0;
					++row;
					++idx;
					continue;
					break;
			}
			this.colCount = Math.max(this.colCount, this.tiles[row].length);
			++idx;
			// Get object, if present.
			switch (levelText[idx]) {
				case " ":
					object = null;
					break;
				case "@":
					object = new Character(this, [row, col]);
					this.characters.add(object);
					++this.characterCount;
					break;
				case "X":
					object = new Crate(this, [row, col]);
					break;
				case "*":
					object = new IceBlock(this, [row, col]);
					break;
			}
			this.objects[row].add(object);
			++idx;
			++col;
		}

		minWidth = this.colCount * MIN_TILE_SIZE;
		minHeight = this.rowCount * MIN_TILE_SIZE;
		this.zoom = Math.max(1, Math.min(Math.floor(1.0 * X_RES / minWidth), Math.floor(1.0 * Y_RES / minHeight)));
		this.tileSize = MIN_TILE_SIZE * this.zoom;
		this.xMargin = (X_RES - this.colCount * this.tileSize) / 2;
		this.yMargin = (Y_RES - this.rowCount * this.tileSize) / 2;

		this.resetSummonKeyboardXY();
	}

	// Gets the currently selected character or null if there are no characters left.
	function getCurrentCharacter() {
		if (this.characters.length == 0) return null;
		this.characterIdx = this.characterIdx % this.characters.length;
		return this.characters[this.characterIdx];
	}

	// Gets the row-column position adjacent to rowCol, towards direction.
	function neighbor(rowCol, direction) {
		switch (direction) {
			case Direction.UP:
				return [(rowCol[0] - 1) % this.rowCount, rowCol[1]];
				break;
			case Direction.DOWN:
				return [(rowCol[0] + 1) % this.rowCount, rowCol[1]];
				break;
			case Direction.LEFT:
				return [rowCol[0], (rowCol[1] - 1) % this.colCount];
				break;
			case Direction.RIGHT:
				return [rowCol[0], (rowCol[1] + 1) % this.colCount];
				break;
		}
	}

	// Advances time by one turn.
	function advanceTime() {
		for (i = 0; i < this.returnPoints.length; ++i) {
			this.returnPoints[i].update();
			if (!this.consistent) {
				return;
			} else if (this.returnPoints[i].satisfied) {
				this.returnPoints.remove(i);
				--i;
			}
		}
		// Characters who wait look down.
		for (character : this.characters) {
			character.direction = Direction.DOWN;
		}
	}

	// Converts (row, col) to (x, y).
	function rowColToXY(rowCol) {
		return [this.xMargin + rowCol[1] * this.tileSize, this.yMargin + rowCol[0] * this.tileSize];
	}

	// Converts (x, y) to (row, col).
	function xyToRowCol(xy) {
		return [(xy[1] - this.yMargin) / this.tileSize, (xy[0] - this.xMargin) / this.tileSize];
	}

	// Attempts to summon the current character at the currently selected position.
	function summonCurrentCharacter() {
		currentCharacter = this.getCurrentCharacter();
		if (currentCharacter != null) {
			summonXY = this.summonKeyboardXY != null ? this.summonKeyboardXY : this.summonMouseXY;
			currentCharacter.summonFromFuture(this.xyToRowCol(summonXY), this.summonTime);
		}
	}

	// Tries to move the current character in the given direction.
	function moveCurrentCharacter(direction) {
		currentCharacter = this.getCurrentCharacter();
		if (currentCharacter != null) {
			// Set direction. This allows the direction to change even if the character fails to move.
			currentCharacter.direction = direction;
			// Try to push.
			currentCharacter.momentum = 2;
			if (currentCharacter.push(direction)) {
				// If the character moved, advance time.
				this.advanceTime();
				// Reset direction since advancing time causes all characters to face down.
				currentCharacter.direction = direction;
			}
		}
	}

	// Sets/resets the keyboard-controlled summon target to the current character.
	function resetSummonKeyboardXY() {
		currentCharacter = this.getCurrentCharacter();
		if (currentCharacter != null) {
			this.summonKeyboardXY = this.rowColToXY(currentCharacter.rowCol);
			this.summonKeyboardXY[0] += this.tileSize / 2;
			this.summonKeyboardXY[1] += this.tileSize / 2;
		} else {
			this.summonKeyboardXY = null;
		}
	}

	// Moves the summon target in the given direction.
	function moveSummonKeyboardXY(direction) {
		if (this.summonKeyboardXY == null) {
			this.resetSummonKeyboardXY();
		}
		switch (direction) {
			case Direction.UP:
				this.summonKeyboardXY[1] -= this.tileSize;
				break;
			case Direction.DOWN:
				this.summonKeyboardXY[1] += this.tileSize;
				break;
			case Direction.LEFT:
				this.summonKeyboardXY[0] -= this.tileSize;
				break;
			case Direction.RIGHT:
				this.summonKeyboardXY[0] += this.tileSize;
				break;
		}
	}

	// Updates the level.
	function update(inputManager, events) {
		this.summoning = inputManager.isShiftPressed();
		if (!this.summoning) {
			this.summonKeyboardXY = null;
		}

		this.summonMouseXY = inputManager.getMousePosition();
		for (e : events) {
			switch (e.type) {
				case EventType.MOUSE_PRESS:
					if (this.summoning) {
						this.summonCurrentCharacter();
					} else {
						// Switch to clicked character, if any.
						clickedPosition = this.xyToRowCol([e.x, e.y]);
						for (i = 0; i < this.characters.length; ++i) {
							characterPosition = this.characters[i].rowCol;
							if (characterPosition[0] == clickedPosition[0] && characterPosition[1] == clickedPosition[1]) {
								this.characterIdx = i;
								break;
							}
						}
					}
					break;
				case EventType.MOUSE_MOVE:
					this.summonKeyboardXY = null;
					break;
				case EventType.KEY:
					if (e.down) {
						if (this.summoning) {
							switch (e.key) {
								case KeyboardKey.SPACE:
									this.summonCurrentCharacter();
									break;
								// Move summon target.
								case KeyboardKey.UP:
									this.moveSummonKeyboardXY(Direction.UP);
									break;
								case KeyboardKey.DOWN:
									this.moveSummonKeyboardXY(Direction.DOWN);
									break;
								case KeyboardKey.LEFT:
									this.moveSummonKeyboardXY(Direction.LEFT);
									break;
								case KeyboardKey.RIGHT:
									this.moveSummonKeyboardXY(Direction.RIGHT);
									break;
								case KeyboardKey.W:
									this.moveSummonKeyboardXY(Direction.UP);
									break;
								case KeyboardKey.S:
									this.moveSummonKeyboardXY(Direction.DOWN);
									break;
								case KeyboardKey.A:
									this.moveSummonKeyboardXY(Direction.LEFT);
									break;
								case KeyboardKey.D:
									this.moveSummonKeyboardXY(Direction.RIGHT);
									break;
								default:
									break;
							}
						} else {
							switch (e.key) {
								case KeyboardKey.SPACE:
									// Try to wait until a character returns to the past.
									if (this.returnPoints.length != 0) {
										// Find the return point that will trigger next.
										idx = 0;
										for (i = 1; i < this.returnPoints.length; ++i) {
											if (this.returnPoints[i].time < this.returnPoints[idx].time) {
												idx = i;
											}
										}
										// Fast forward if the character is in position.
										if (this.returnPoints[idx].ready()) {
											time = this.returnPoints[idx].time;
											for (i = 0; i < time; ++i) {
												this.advanceTime();
												if (!this.consistent) {
													return;
												}
											}
										}
									}
									break;
								case KeyboardKey.Z:
									// Wait one turn.
									this.advanceTime();
									break;
								case KeyboardKey.Q:
									// Previous character.
									--this.characterIdx;
									break;
								case KeyboardKey.E:
									// Next character.
									++this.characterIdx;
									break;
								// Move current character.
								case KeyboardKey.UP:
									this.moveCurrentCharacter(Direction.UP);
									break;
								case KeyboardKey.DOWN:
									this.moveCurrentCharacter(Direction.DOWN);
									break;
								case KeyboardKey.LEFT:
									this.moveCurrentCharacter(Direction.LEFT);
									break;
								case KeyboardKey.RIGHT:
									this.moveCurrentCharacter(Direction.RIGHT);
									break;
								case KeyboardKey.W:
									this.moveCurrentCharacter(Direction.UP);
									break;
								case KeyboardKey.S:
									this.moveCurrentCharacter(Direction.DOWN);
									break;
								case KeyboardKey.A:
									this.moveCurrentCharacter(Direction.LEFT);
									break;
								case KeyboardKey.D:
									this.moveCurrentCharacter(Direction.RIGHT);
									break;
								default:
									break;
							}
						}
					}
					break;
				default:
					break;
			}
		}
	}

	// Draws a 21 x 21 tile image at the given row-column position, with the given offsets (at 1 x zoom).
	function drawTile(image, rowCol, offset = [0, 0]) {
		xy = this.rowColToXY(rowCol);
		image.drawStretched
			( xy[0] + offset[0] * this.zoom
			, xy[1] + offset[1] * this.zoom
			, image.width * this.zoom
			, image.height * this.zoom
			);
	}

	// Draws a number to the upper-left of (x, y).
	function drawNumber(n, xy, color = [255, 255, 255]) {
		x = xy[0];
		y_bottom = xy[1];
		while (n > 0) {
			digit = n % 10;
			n /= 10;
			image = Images.get("images/" + digit + ".png");
			x -= image.width * this.zoom;
			y = y_bottom - image.height * this.zoom;
			width = image.width * this.zoom;
			height = image.height * this.zoom;
			Graphics2D.Draw.rectangle(x, y, width, height, color[0], color[1], color[2]);
			image.drawStretched(x, y, width, height);
		}
	}

	// Draws the level to the screen.
	function draw() {
		for (row = 0; row < this.rowCount; ++row) {
			for (col = 0; col < this.colCount; ++col) {
				// Draw tiles.
				tile = this.tiles[row][col];
				if (tile != null) {
					tile.draw();
				}

				// Draw objects.
				object = this.objects[row][col];
				if (object != null) {
					object.draw();
				}
			}
		}

		// Draw return points.
		for (returnPoint : this.returnPoints) {
			returnPoint.draw();
		}

		// Draw mouse hover highlight, if summoning.
		if (this.summoning) {
			summonXY = this.summonKeyboardXY != null ? this.summonKeyboardXY : this.summonMouseXY;
			hoveredRowCol = this.xyToRowCol(summonXY);
			highlightXY = this.rowColToXY(hoveredRowCol);
			currentCharacter = this.getCurrentCharacter();
			highlightRGB = (currentCharacter != null && currentCharacter.canSummonAt(hoveredRowCol))
				? [255, 255, 255]
				: [255, 96, 96]
				;
			Graphics2D.Draw.rectangle
				( highlightXY[0] + this.zoom, highlightXY[1] + this.zoom
				, this.tileSize - this.zoom, this.tileSize - this.zoom
				, highlightRGB[0], highlightRGB[1], highlightRGB[2], 128
				);
			this.drawNumber(this.summonTime, summonXY);
		}
	}
}
