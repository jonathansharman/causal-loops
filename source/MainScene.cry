import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import Resources;
import TwoCansAlpha2;
import UserData;

const X_RES = 640;
const Y_RES = 480;

const TILE_SIZE = 20;
const COL_COUNT = X_RES / TILE_SIZE;
const ROW_COUNT = Y_RES / TILE_SIZE;

enum Tile { FLOOR, WALL, ICE, STAIRS }

enum Direction { UP, DOWN, LEFT, RIGHT }

class Object {
	// row-col
	field position;

	constructor(position) {
		this.position = position;
	}

	function draw() {
		throw new Exception("Abstract method not implemented.");
	}
}

class Character : Object {
	field direction = Direction.DOWN;
	field returnPoint = null;

	constructor(position) : base(position) {}

	function draw() {
		switch (this.direction) {
			case Direction.UP:
				image = Images.get("images/character-up.png");
				break;
			case Direction.DOWN:
				image = Images.get("images/character-down.png");
				break;
			case Direction.LEFT:
				image = Images.get("images/character-left.png");
				break;
			case Direction.RIGHT:
				image = Images.get("images/character-right.png");
				break;
		}
		image.draw(this.position[1] * TILE_SIZE, this.position[0] * TILE_SIZE);
	}
}

class Crate : Object {
	constructor(position) : base(position) {}

	function draw() {
		Images.get("images/crate.png").draw(this.position[1] * TILE_SIZE, this.position[0] * TILE_SIZE);
	}
}

class ReturnPoint : Object {
	field time;
	field character;

	constructor(position, time, character) : base(position) {
		this.time = time;
		this.character = character;
	}

	function draw() {
		xCharacter = this.character.position[1] * TILE_SIZE;
		yCharacter = this.character.position[0] * TILE_SIZE;
		// Draw triangle from character to return point, if not at same position.
		if (this.character.position[0] != this.position[0] || this.character.position[1] != this.position[1]) {
			angle = Math.arctan
				( this.character.position[0] - this.position[0]
				, this.character.position[1] - this.position[1]
				);
			Graphics2D.Draw.triangle
				( xCharacter + TILE_SIZE / 2.0 * (1.0 + Math.cos(angle + Math.PI / 4.0))
				, yCharacter + TILE_SIZE / 2.0 * (1.0 + Math.sin(angle + Math.PI / 4.0))
				, xCharacter + TILE_SIZE / 2.0 * (1.0 + Math.cos(angle - Math.PI / 4.0))
				, yCharacter + TILE_SIZE / 2.0 * (1.0 + Math.sin(angle - Math.PI / 4.0))
				, TILE_SIZE * (this.position[1] + 0.5), TILE_SIZE * (this.position[0] + 0.5)
				, 0, 0, 0, 64
				);
		}
		// Draw time.
		time = this.time;
		x = xCharacter + TILE_SIZE;
		while (time > 0) {
			digit = time % 10;
			time /= 10;
			image = Images.get("images/" + digit + ".png");
			x -= image.width;
			y = yCharacter + TILE_SIZE - image.height;
			image.draw(x, y);
		}
	}
}

class MainScene : AbstractScene {
	field tiles;
	field objects;
	field characters;
	field returnPoints;

	field characterIdx = 0;

	field mousePosition;

	constructor() : base() {
		//this.randomizeLevel();
		this.loadLevel("levels/1.txt");
	}

	// Creates a semi-random level.
	function randomizeLevel() {
		this.tiles = [];
		this.objects = [];
		this.characters = [];
		this.returnPoints = [];
		for (row = 0; row < ROW_COUNT; ++row) {
			this.tiles.add([]);
			this.objects.add([]);
			for (col = 0; col < COL_COUNT; ++col) {
				if (row == 0 || row == ROW_COUNT - 1 || col == 0 || col == COL_COUNT - 1) {
					// Outer wall.
					this.tiles[row].add(Tile.WALL);
					this.objects[row].add(null);
				} else if (row == ROW_COUNT - 2 && col == COL_COUNT - 2) {
					// Stairs.
					this.tiles[row].add(Tile.STAIRS);
					this.objects[row].add(null);
				} else {
					if (Random.randomInt(5) == 0) {
						// Ice.
						this.tiles[row].add(Tile.ICE);
					} else {
						// Floor.
						this.tiles[row].add(Tile.FLOOR);
					}

					if (row == 1 && col == 1) {
						// Character.
						object = new Character([row, col]);
						this.characters.add(object);
					} else if (Random.randomInt(10) == 0) {
						// Crate.
						object = new Crate([row, col]);
					} else {
						object = null;
					}
					this.objects[row].add(object);
				}
			}
		}
	}

	// Loads a level from a file.
	function loadLevel(filename) {
		this.tiles = [[]];
		this.objects = [[]];
		this.characters = [];
		this.returnPoints = [];

		levelText = Resources.readText(filename);
		row = 0;
		col = 0;
		idx = 0;
		while (idx < levelText.length) {
			// Get tile.
			switch (levelText[idx]) {
				case ".":
					this.tiles[row].add(Tile.FLOOR);
					break;
				case "#":
					this.tiles[row].add(Tile.WALL);
					break;
				case "/":
					this.tiles[row].add(Tile.ICE);
					break;
				case ">":
					this.tiles[row].add(Tile.STAIRS);
					break;
				default:
					this.tiles.add([]);
					this.objects.add([]);
					col = 0;
					++row;
					++idx;
					continue;
					break;
			}
			++idx;
			// Get object, if present.
			switch (levelText[idx]) {
				case " ":
					object = null;
					break;
				case "@":
					object = new Character([row, col]);
					this.characters.add(object);
					break;
				case "X":
					object = new Crate([row, col]);
					break;
			}
			this.objects[row].add(object);
			++idx;
			++col;
		}
	}

	// Gets the position adjacent to "position", towards "direction".
	static function neighbor(position, direction) {
		switch (direction) {
			case Direction.UP:
				return [(position[0] - 1) % ROW_COUNT, position[1]];
				break;
			case Direction.DOWN:
				return [(position[0] + 1) % ROW_COUNT, position[1]];
				break;
			case Direction.LEFT:
				return [position[0], (position[1] - 1) % COL_COUNT];
				break;
			case Direction.RIGHT:
				return [position[0], (position[1] + 1) % COL_COUNT];
				break;
		}
	}

	// Pushes "object" towards "direction", along with anything in the way, if "strength" >= # of objects to push.
	function push(object, direction, strength = 2) {
		// Can't push anything with no strength.
		if (strength == 0) return false;

		// Get neighboring position.
		neighborPosition = MainScene.neighbor(object.position, direction);

		// Push neighbor, if any.
		neighbor = this.objects[neighborPosition[0]][neighborPosition[1]];
		if (neighbor != null && !this.push(neighbor, direction, strength - 1)) {
			// Too much stuff in the way.
			return false;
		}

		// Try to push object.
		neighborTile = this.tiles[neighborPosition[0]][neighborPosition[1]];
		if (neighborTile == Tile.WALL) {
			return false;
		} else {
			// Move one.
			this.objects[object.position[0]][object.position[1]] = null;
			this.objects[neighborPosition[0]][neighborPosition[1]] = object;
			object.position = neighborPosition;
		}
		if (this.tiles[object.position[0]][object.position[1]] == Tile.ICE) {
			// Slide.
			this.push(object, direction, strength);
		}
		return true;
	}

	// Summons the current character from the future at the given target coordinates.
	function summonFromFuture(target) {
		// Can't summon more than one future character from the character instance.
		if (this.characters[this.characterIdx].returnPoint != null) return;

		row = target[0];
		col = target[1];

		// Need an empty spot.
		if (this.objects[row][col] != null) return;

		currentCharacter = this.characters[this.characterIdx];
		// Create future character.
		futureCharacter = new Character(target.clone());
		this.objects[row][col] = futureCharacter;
		// Add the new character after the current character and switch control to it.
		this.characters.insert(this.characterIdx + 1, futureCharacter);
		++this.characterIdx;
		// Create a return point where the future character came from.
		returnPoint = new ReturnPoint(target.clone(), 20, currentCharacter);
		// Set the current character as the character who needs to return to the return point.
		currentCharacter.returnPoint = returnPoint;
		// Andvance time.
		this.advanceTime();
		// Add the return point to the list after advancing time so it starts at max time.
		this.returnPoints.add(returnPoint);
	}

	// Advances time by one turn.
	function advanceTime() {
		for (i = 0; i < this.returnPoints.length; ++i) {
			returnPoint = this.returnPoints[i];
			character = returnPoint.character;
			position = returnPoint.position;
			--returnPoint.time;
			if (returnPoint.time == 0) {
				if (character.position[0] == position[0] && character.position[1] == position[1]) {
					// Remove character.
					for (j = 0; j < this.characters.length; ++j) {
						if (this.characters[j] == character) {
							this.objects[position[0]][position[1]] = null;
							this.characters.remove(j);
							if (this.characterIdx > j) {
								--this.characterIdx;
							}
							break;
						}
					}
					// Remove return point.
					this.returnPoints.remove(i);
					--i;
				} else {
					// Logical inconsistency!
					this.switchScene(new MainScene());
					return;
				}
			}
		}
		// Characters who wait look down.
		for (character : this.characters) {
			character.direction = Direction.DOWN;
		}
	}

	function update(inputManager, events) {
		if (inputManager.isKeyPressedThisFrame(KeyboardKey.ESCAPE)) {
			this.switchScene(new MainScene());
			return;
		}

		for (e : events) {
			if (e.type == EventType.MOUSE_PRESS) {
				// Summon.
				this.summonFromFuture([e.y / TILE_SIZE, e.x / TILE_SIZE]);
			} else if (e.type == EventType.KEY && e.down) {
				direction = null;
				switch (e.key) {
					case KeyboardKey.Q:
						// Previous character.
						this.characterIdx = (this.characterIdx - 1) % this.characters.length;
						break;
					case KeyboardKey.E:
						// Next character.
						this.characterIdx = (this.characterIdx + 1) % this.characters.length;
						break;
					case KeyboardKey.SPACE:
						// Wait.
						this.advanceTime();
						break;
					// Movement commands.
					case KeyboardKey.UP:    direction = Direction.UP;    break;
					case KeyboardKey.DOWN:  direction = Direction.DOWN;  break;
					case KeyboardKey.LEFT:  direction = Direction.LEFT;  break;
					case KeyboardKey.RIGHT: direction = Direction.RIGHT; break;
					case KeyboardKey.W:     direction = Direction.UP;    break;
					case KeyboardKey.S:     direction = Direction.DOWN;  break;
					case KeyboardKey.A:     direction = Direction.LEFT;  break;
					case KeyboardKey.D:     direction = Direction.RIGHT; break;
					default:
						break;
				}
				if (direction != null) {
					// Try to move the current character.
					if (this.push(this.characters[this.characterIdx], direction)) {
						// If the character moved, advance time.
						this.advanceTime();
						// Update character's direction.
						this.characters[this.characterIdx].direction = direction;
					}
				}
			}
		}

		// Check for victory.
		if (this.characters.length == 1) {
			if (this.tiles[this.characters[0].position[0]][this.characters[0].position[1]] == Tile.STAIRS) {
				this.switchScene(new MainScene());
				return;
			}
		}

		this.mousePosition = inputManager.getMousePosition();
	}

	function render() {
		Graphics2D.Draw.fill(255, 255, 255);

		for (row = 0; row < ROW_COUNT; ++row) {
			for (col = 0; col < COL_COUNT; ++col) {
				// Draw tiles.
				x = col * TILE_SIZE;
				y = row * TILE_SIZE;
				switch (this.tiles[row][col]) {
					case Tile.WALL:
						image = Images.get("images/wall.png");
						break;
					case Tile.FLOOR:
						image = Images.get("images/floor.png");
						break;
					case Tile.ICE:
						image = Images.get("images/ice.png");
						break;
					case Tile.STAIRS:
						image = Images.get("images/stairs.png");
						break;
				}
				image.draw(x, y);

				// Draw objects.
				object = this.objects[row][col];
				if (object != null) {
					object.draw();
					// Draw selector.
					if (this.characters.length > 1 && object == this.characters[this.characterIdx]) {
						Images.get("images/selector.png").draw(x, y);
					}
				}
			}
		}

		// Draw return points.
		for (returnPoint : this.returnPoints) {
			returnPoint.draw();
		}

		// Draw mouse hover highlight.
		Graphics2D.Draw.rectangle
			( this.mousePosition[0] / TILE_SIZE * TILE_SIZE + 1, this.mousePosition[1] / TILE_SIZE * TILE_SIZE + 1
			, TILE_SIZE - 1, TILE_SIZE - 1
			, 255, 255, 255, 128
			);
	}
}
