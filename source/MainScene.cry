import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import TwoCansAlpha2;
import UserData;

const X_RES = 640;
const Y_RES = 480;

const TILE_SIZE = 20;
const COL_COUNT = X_RES / TILE_SIZE;
const ROW_COUNT = Y_RES / TILE_SIZE;

enum Tile { FLOOR, WALL, ICE, STAIRS }

enum Direction { UP, DOWN, LEFT, RIGHT }

class Object {
	field position;

	constructor(position) {
		this.position = position;
	}

	function draw() {
		throw new Exception("Abstract method not implemented.");
	}
}

class Character : Object {
	field direction = Direction.DOWN;
	field returnPoint = null;

	constructor(position) : base(position) {}

	function draw() {
		switch (this.direction) {
			case Direction.UP:
				image = Images.get("character-up.png");
				break;
			case Direction.DOWN:
				image = Images.get("character-down.png");
				break;
			case Direction.LEFT:
				image = Images.get("character-left.png");
				break;
			case Direction.RIGHT:
				image = Images.get("character-right.png");
				break;
		}
		image.draw(this.position[0] * TILE_SIZE, this.position[1] * TILE_SIZE);
	}
}

class Crate : Object {
	constructor(position) : base(position) {}

	function draw() {
		Images.get("crate.png").draw(this.position[0] * TILE_SIZE, this.position[1] * TILE_SIZE);
	}
}

class ReturnPoint : Object {
	field time;
	field character;

	field image;

	constructor(position, time, character) : base(position) {
		this.time = time;
		this.character = character;
		this.renderImage();
	}

	function renderImage() {
		this.image = MainScene.font.render(this.time);
	}

	function countDown() {
		--this.time;
		this.renderImage();
	}

	function draw() {
		xCharacter = this.character.position[0] * TILE_SIZE;
		yCharacter = this.character.position[1] * TILE_SIZE;
		// Draw line between return point and character.
		Graphics2D.Draw.triangle
			( (this.position[0] + 0.5) * TILE_SIZE, (this.position[1] + 0.5) * TILE_SIZE
			, xCharacter + TILE_SIZE / 2.0, yCharacter
			, xCharacter + TILE_SIZE / 2.0, yCharacter + TILE_SIZE
			, 0, 0, 0, 64
			);
		// Draw counter on character.
		Graphics2D.Draw.rectangle
			( xCharacter + TILE_SIZE - this.image.width, yCharacter + TILE_SIZE - this.image.height
			, this.image.width, this.image.height
			, 0, 0, 0, 64
			);
		this.image.draw(xCharacter + TILE_SIZE - this.image.width, yCharacter + TILE_SIZE - this.image.height);
	}
}

class MainScene : AbstractScene {
	static field font = FontResource.fromResource("Inconsolata-Bold.ttf").getRenderer()
		.setSize(9)
		.setStyle(FontStyle.BOLD)
		.setColor(255, 255, 255);

	field tiles;
	field objects;
	field characters;
	field returnPoints;

	field characterIdx = 0;

	field mousePosition;

	constructor() : base() {
		this.randomizeLevel();
	}

	function randomizeLevel() {
		this.tiles = [];
		this.objects = [];
		this.characters = [];
		this.returnPoints = [];
		for (x = 0; x < COL_COUNT; ++x) {
			this.tiles.add([]);
			this.objects.add([]);
			for (y = 0; y < ROW_COUNT; ++y) {
				if (y == 0 || y == ROW_COUNT - 1 || x == 0 || x == COL_COUNT - 1) {
					// Outer wall.
					this.tiles[x].add(Tile.WALL);
					this.objects[x].add(null);
				} else if (y == ROW_COUNT - 2 && x == COL_COUNT - 2) {
					// Stairs.
					this.tiles[x].add(Tile.STAIRS);
					this.objects[x].add(null);
				} else {
					if (Random.randomInt(5) == 0) {
						// Ice.
						this.tiles[x].add(Tile.ICE);
					} else {
						// Floor.
						this.tiles[x].add(Tile.FLOOR);
					}

					if (y == 1 && x == 1) {
						// Character.
						object = new Character([x, y]);
						this.characters.add(object);
					} else if (Random.randomInt(10) == 0) {
						// Crate.
						object = new Crate([x, y]);
					} else {
						object = null;
					}
					this.objects[x].add(object);
				}
			}
		}
	}

	// Gets the position adjacent to the given position in the given direction.
	static function neighbor(position, direction) {
		switch (direction) {
			case Direction.UP:
				return [position[0], position[1] - 1];
				break;
			case Direction.DOWN:
				return [position[0], position[1] + 1];
				break;
			case Direction.LEFT:
				return [position[0] - 1, position[1]];
				break;
			case Direction.RIGHT:
				return [position[0] + 1, position[1]];
				break;
		}
	}

	// Pushes the given object in the given direction, along with anything in the way,
	// as long as the strength parameter is >= the number of objects to push.
	function push(object, direction, strength = 2) {
		// Can't push anything with no strength.
		if (strength == 0) return false;

		// Get neighboring position.
		neighborPosition = MainScene.neighbor(object.position, direction);

		// Push neighbor, if any.
		neighbor = this.objects[neighborPosition[0]][neighborPosition[1]];
		if (neighbor != null && !this.push(neighbor, direction, strength - 1)) {
			// Too much stuff in the way.
			return false;
		}

		// Try to push object.
		neighborTile = this.tiles[neighborPosition[0]][neighborPosition[1]];
		if (neighborTile == Tile.WALL) {
			return false;
		} else {
			// Move one.
			this.objects[object.position[0]][object.position[1]] = null;
			this.objects[neighborPosition[0]][neighborPosition[1]] = object;
			object.position = neighborPosition;
		}
		if (this.tiles[object.position[0]][object.position[1]] == Tile.ICE) {
			// Slide.
			this.push(object, direction, strength);
		}
		return true;
	}

	// Summons the current character from the future at the given coordinates.
	function summonFromFuture(target) {
		// Can't summon more than one future character from the character instance.
		if (this.characters[this.characterIdx].returnPoint != null) return;

		x = target[0];
		y = target[1];

		// Need an empty spot.
		if (this.objects[x][y] != null) return;

		currentCharacter = this.characters[this.characterIdx];
		// Create future character.
		futureCharacter = new Character(target.clone());
		this.objects[x][y] = futureCharacter;
		// Add the new character after the current character and switch control to it.
		this.characters.insert(this.characterIdx + 1, futureCharacter);
		++this.characterIdx;
		// Create a return point where the future character came from.
		returnPoint = new ReturnPoint(target.clone(), 20, currentCharacter);
		// Set the current character as the character who needs to return to the return point.
		currentCharacter.returnPoint = returnPoint;
		// Andvance time.
		this.advanceTime();
		// Add the return point to the list after advancing time so it starts at max time.
		this.returnPoints.add(returnPoint);
	}

	function advanceTime() {
		for (i = 0; i < this.returnPoints.length; ++i) {
			returnPoint = this.returnPoints[i];
			character = returnPoint.character;
			position = returnPoint.position;
			returnPoint.countDown();
			if (returnPoint.time == 0) {
				if (character.position[0] == position[0] && character.position[1] == position[1]) {
					// Remove character.
					for (j = 0; j < this.characters.length; ++j) {
						if (this.characters[j] == character) {
							this.objects[position[0]][position[1]] = null;
							this.characters.remove(j);
							if (this.characterIdx > j) {
								--this.characterIdx;
							}
							break;
						}
					}
					// Remove return point.
					this.returnPoints.remove(i);
					--i;
				} else {
					// Logical inconsistency!
					this.switchScene(new MainScene());
					return;
				}
			}
		}
	}

	function update(inputManager, events) {
		if (inputManager.isKeyPressedThisFrame(KeyboardKey.ESCAPE)) {
			this.switchScene(new MainScene());
			return;
		}

		for (e : events) {
			if (e.type == EventType.MOUSE_PRESS) {
				// Summon.
				this.summonFromFuture([e.x / TILE_SIZE, e.y / TILE_SIZE]);
			} else if (e.type == EventType.KEY && e.down) {
				direction = null;
				switch (e.key) {
					case KeyboardKey.Q:
						// Previous character.
						this.characterIdx = (this.characterIdx - 1) % this.characters.length;
						break;
					case KeyboardKey.E:
						// Next character.
						this.characterIdx = (this.characterIdx + 1) % this.characters.length;
						break;
					case KeyboardKey.SPACE:
						// Wait.
						this.advanceTime();
						break;
					case KeyboardKey.UP:
						direction = Direction.UP;
						break;
					case KeyboardKey.DOWN:
						direction = Direction.DOWN;
						break;
					case KeyboardKey.LEFT:
						direction = Direction.LEFT;
						break;
					case KeyboardKey.RIGHT:
						direction = Direction.RIGHT;
						break;
					case KeyboardKey.W:
						direction = Direction.UP;
						break;
					case KeyboardKey.S:
						direction = Direction.DOWN;
						break;
					case KeyboardKey.A:
						direction = Direction.LEFT;
						break;
					case KeyboardKey.D:
						direction = Direction.RIGHT;
						break;
					default:
						break;
				}
				if (direction != null) {
					// Try to move the current character.
					if (this.push(this.characters[this.characterIdx], direction)) {
						// If the character moved, advance time.
						this.advanceTime();
						// Update character's direction.
						this.characters[this.characterIdx].direction = direction;
					}
				}
			}
		}

		// Check for victory.
		if (this.characters.length == 1) {
			if (this.tiles[this.characters[0].position[0]][this.characters[0].position[1]] == Tile.STAIRS) {
				this.switchScene(new MainScene());
				return;
			}
		}

		this.mousePosition = inputManager.getMousePosition();
	}

	function render() {
		Graphics2D.Draw.fill(255, 255, 255);

		for (x = 0; x < COL_COUNT; ++x) {
			for (y = 0; y < ROW_COUNT; ++y) {
				// Draw tiles.
				xScreen = x * TILE_SIZE;
				yScreen = y * TILE_SIZE;
				switch (this.tiles[x][y]) {
					case Tile.WALL:
						image = Images.get("wall.png");
						break;
					case Tile.FLOOR:
						image = Images.get("floor.png");
						break;
					case Tile.ICE:
						image = Images.get("ice.png");
						break;
					case Tile.STAIRS:
						image = Images.get("stairs.png");
						break;
				}
				image.draw(xScreen, yScreen);

				// Draw objects.
				object = this.objects[x][y];
				if (object != null) {
					object.draw();
					// Draw selector.
					if (this.characters.length > 1 && object == this.characters[this.characterIdx]) {
						Images.get("selector.png").draw(object.position[0] * TILE_SIZE, object.position[1] * TILE_SIZE);
					}
				}
			}
		}

		// Draw return points.
		for (returnPoint : this.returnPoints) {
			returnPoint.draw();
		}

		// Draw mouse hover highlight.
		Graphics2D.Draw.rectangle
			( this.mousePosition[0] / TILE_SIZE * TILE_SIZE + 1, this.mousePosition[1] / TILE_SIZE * TILE_SIZE + 1
			, TILE_SIZE - 1, TILE_SIZE - 1
			, 255, 255, 255, 128
			);
	}
}
