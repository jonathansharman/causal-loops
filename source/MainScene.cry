import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import TwoCansAlpha2;
import UserData;

const X_RES = 640;
const Y_RES = 480;

const TILE_SIZE = 32;
const COL_COUNT = X_RES / TILE_SIZE;
const ROW_COUNT = Y_RES / TILE_SIZE;

enum Tile { FLOOR, WALL, ICE }

enum Direction { UP, DOWN, LEFT, RIGHT }

class Object {
	field position;

	constructor(position) {
		this.position = position;
	}

	function draw() {
		this.getImage().draw(this.position[0] * TILE_SIZE, this.position[1] * TILE_SIZE);
	}

	function getImage() {
		throw new Exception("Abstract method not implemented.");
	}
}

class Player : Object {
	constructor(position) : base(position) {}

	function getImage() {
		return Images.get("player.png");
	}
}

class Crate : Object {
	constructor(position) : base(position) {}

	function getImage() {
		return Images.get("crate.png");
	}
}

class MainScene : AbstractScene {
	field tiles;
	field objects;
	field players;

	constructor() : base() {
		this.randomizeLevel();
	}

	function randomizeLevel() {
		this.tiles = [];
		this.objects = [];
		this.players = [];
		for (x = 0; x < COL_COUNT; ++x) {
			this.tiles.add([]);
			this.objects.add([]);
			for (y = 0; y < ROW_COUNT; ++y) {
				if (y == 0 || y == ROW_COUNT - 1 || x == 0 || x == COL_COUNT - 1) {
					this.tiles[x].add(Tile.WALL);
					this.objects[x].add(null);
				} else {
					if (Random.randomInt(5) == 0) {
						this.tiles[x].add(Tile.ICE);
					} else {
						this.tiles[x].add(Tile.FLOOR);
					}

					if (y == 1 && x == 1) {
						object = new Player([x, y]);
						this.players.add(object);
					} else if (Random.randomInt(10) == 0) {
						object = new Crate([x, y]);
					} else {
						object = null;
					}
					this.objects[x].add(object);
				}
			}
		}
	}

	// Gets the position adjacent to the given position in the given direction.
	static function neighbor(position, direction) {
		switch (direction) {
			case Direction.UP:
				return [position[0], position[1] - 1];
				break;
			case Direction.DOWN:
				return [position[0], position[1] + 1];
				break;
			case Direction.LEFT:
				return [position[0] - 1, position[1]];
				break;
			case Direction.RIGHT:
				return [position[0] + 1, position[1]];
				break;
		}
	}

	// Pushes the given object in the given direction, along with anything in the way,
	// as long as the strength parameter is >= the number of objects to push.
	function push(object, direction, strength = 2) {
		// Can't push anything with no strength.
		if (strength == 0) return false;

		// Get neighboring position.
		neighborPosition = MainScene.neighbor(object.position, direction);

		// Push neighbor, if any.
		neighbor = this.objects[neighborPosition[0]][neighborPosition[1]];
		if (neighbor != null && !this.push(neighbor, direction, strength - 1)) {
			// Too much stuff in the way.
			return false;
		}

		// Try to push object.
		neighborTile = this.tiles[neighborPosition[0]][neighborPosition[1]];
		if (neighborTile == Tile.WALL) {
			return false;
		} else {
			// Move one.
			this.objects[object.position[0]][object.position[1]] = null;
			this.objects[neighborPosition[0]][neighborPosition[1]] = object;
			object.position = neighborPosition;
		}
		if (this.tiles[object.position[0]][object.position[1]] == Tile.ICE) {
			// Slide.
			this.push(object, direction, strength);
		}
		return true;
	}

	function update(inputManager, events) {
		if (inputManager.isKeyPressedThisFrame(KeyboardKey.ESCAPE)) {
			this.switchScene(new MainScene());
			return;
		}

		for (e : events) {
			if (e.type == EventType.KEY && e.down) {
				switch (e.key) {
					case KeyboardKey.UP:
						direction = Direction.UP;
						break;
					case KeyboardKey.DOWN:
						direction = Direction.DOWN;
						break;
					case KeyboardKey.LEFT:
						direction = Direction.LEFT;
						break;
					case KeyboardKey.RIGHT:
						direction = Direction.RIGHT;
						break;
					default:
						direction = null;
						break;
				}
				if (direction != null) {
					this.push(this.players[0], direction);
				}
			}
		}
	}

	function render() {
		Graphics2D.Draw.fill(255, 255, 255);

		for (x = 0; x < COL_COUNT; ++x) {
			for (y = 0; y < ROW_COUNT; ++y) {
				switch (this.tiles[x][y]) {
					case Tile.WALL:
						image = Images.get("wall.png");
						break;
					case Tile.FLOOR:
						image = Images.get("floor.png");
						break;
					case Tile.ICE:
						image = Images.get("ice.png");
						break;
				}
				image.draw(x * TILE_SIZE, y * TILE_SIZE);

				object = this.objects[x][y];
				if (object != null) {
					object.draw();
				}
			}
		}
	}
}
