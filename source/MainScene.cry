import Graphics2D;
import Graphics2DText;
import Math;
import Random;
import Resources;
import TwoCansAlpha2;
import UserData;

const X_RES = 640;
const Y_RES = 480;

const TILE_SIZE = 20;
const MAX_COL_COUNT = X_RES / TILE_SIZE;
const MAX_ROW_COUNT = Y_RES / TILE_SIZE;

enum Tile { FLOOR, WALL, ICE, STAIRS, HOLE }

enum Direction { UP, DOWN, LEFT, RIGHT }

// An object in the level.
class Object {
	// The level this object is in.
	field level;
	// Row-column position.
	field position;

	constructor(level, position) {
		this.level = level;
		this.position = position;
	}

	function draw() {
		throw new Exception("Abstract method not implemented.");
	}
}

class Character : Object {
	field direction = Direction.DOWN;
	field returnPoint = null;

	constructor(level, position) : base(level, position) {}

	function draw() {
		switch (this.direction) {
			case Direction.UP:
				image = Images.get("images/character-up.png");
				break;
			case Direction.DOWN:
				image = Images.get("images/character-down.png");
				break;
			case Direction.LEFT:
				image = Images.get("images/character-left.png");
				break;
			case Direction.RIGHT:
				image = Images.get("images/character-right.png");
				break;
		}
		xy = this.level.rowColToXY(this.position[0], this.position[1]);
		image.draw(xy[0], xy[1]);
	}
}

class Crate : Object {
	constructor(level, position) : base(level, position) {}

	function draw() {
		xy = this.level.rowColToXY(this.position[0], this.position[1]);
		Images.get("images/crate.png").draw(xy[0], xy[1]);
	}
}

class IceBlock : Object {
	constructor(level, position) : base(level, position) {}

	function draw() {
		xy = this.level.rowColToXY(this.position[0], this.position[1]);
		Images.get("images/ice-block.png").draw(xy[0], xy[1]);
	}
}

class ReturnPoint : Object {
	field time;
	field character;

	constructor(level, position, time, character) : base(level, position) {
		this.time = time;
		this.character = character;
	}

	function draw() {
		xy = this.level.rowColToXY(this.position[0], this.position[1]);
		xyCharacter = this.level.rowColToXY(this.character.position[0], this.character.position[1]);
		// Draw triangle from character to return point, if not at same position.
		if (this.character.position[0] != this.position[0] || this.character.position[1] != this.position[1]) {
			angle = Math.arctan
				( this.character.position[0] - this.position[0]
				, this.character.position[1] - this.position[1]
				);
			Graphics2D.Draw.triangle
				( xyCharacter[0] + TILE_SIZE / 2.0 * (1.0 + Math.cos(angle + Math.PI / 4.0))
				, xyCharacter[1] + TILE_SIZE / 2.0 * (1.0 + Math.sin(angle + Math.PI / 4.0))
				, xyCharacter[0] + TILE_SIZE / 2.0 * (1.0 + Math.cos(angle - Math.PI / 4.0))
				, xyCharacter[1] + TILE_SIZE / 2.0 * (1.0 + Math.sin(angle - Math.PI / 4.0))
				, xy[0] + TILE_SIZE / 2.0, xy[1] + TILE_SIZE / 2.0
				, 0, 0, 0, 64
				);
		}
		// Draw time.
		time = this.time;
		x = xyCharacter[0] + TILE_SIZE;
		while (time > 0) {
			digit = time % 10;
			time /= 10;
			image = Images.get("images/" + digit + ".png");
			x -= image.width;
			y = xyCharacter[1] + TILE_SIZE - image.height;
			image.draw(x, y);
		}
	}
}

class MainScene : AbstractScene {
	field rowCount;
	field colCount;
	field xMargin;
	field yMargin;
	field tiles;
	field objects;
	field characters;
	field returnPoints;

	field characterIdx = 0;

	field mousePosition;

	constructor() : base() {
		//this.randomizeLevel();
		this.loadLevel("levels/test-1.txt");
	}

	// Creates a semi-random level.
	function randomizeLevel() {
		this.rowCount = MAX_ROW_COUNT;
		this.colCount = MAX_COL_COUNT;
		this.tiles = [];
		this.objects = [];
		this.characters = [];
		this.returnPoints = [];
		for (row = 0; row < this.rowCount; ++row) {
			this.tiles.add([]);
			this.objects.add([]);
			for (col = 0; col < this.colCount; ++col) {
				if (row == 0 || row == this.rowCount - 1 || col == 0 || col == this.colCount - 1) {
					// Outer wall.
					this.tiles[row].add(Tile.WALL);
					this.objects[row].add(null);
				} else if (row == this.rowCount - 2 && col == this.colCount - 2) {
					// Stairs.
					this.tiles[row].add(Tile.STAIRS);
					this.objects[row].add(null);
				} else {
					if (Random.randomInt(5) == 0) {
						// Ice.
						this.tiles[row].add(Tile.ICE);
					} else {
						// Floor.
						this.tiles[row].add(Tile.FLOOR);
					}

					if (row == 1 && col == 1) {
						// Character.
						object = new Character(this, [row, col]);
						this.characters.add(object);
					} else if (Random.randomInt(10) == 0) {
						// Crate.
						object = new Crate(this, [row, col]);
					} else {
						object = null;
					}
					this.objects[row].add(object);
				}
			}
		}
		this.xMargin = (X_RES - this.rowCount * TILE_SIZE) / 2;
		this.yMargin = (Y_RES - this.colCount * TILE_SIZE) / 2;
	}

	// Loads a level from a file.
	function loadLevel(filename) {
		this.rowCount = 0;
		this.colCount = 0;
		this.tiles = [[]];
		this.objects = [[]];
		this.characters = [];
		this.returnPoints = [];

		levelText = Resources.readText(filename);
		row = 0;
		col = 0;
		idx = 0;
		while (idx < levelText.length) {
			// Get tile.
			switch (levelText[idx]) {
				case ".":
					this.tiles[row].add(Tile.FLOOR);
					break;
				case "#":
					this.tiles[row].add(Tile.WALL);
					break;
				case "/":
					this.tiles[row].add(Tile.ICE);
					break;
				case ">":
					this.tiles[row].add(Tile.STAIRS);
					break;
				case "O":
					this.tiles[row].add(Tile.HOLE);
					break;
				default:
					this.tiles.add([]);
					this.objects.add([]);
					this.rowCount = Math.max(this.rowCount, this.tiles.length);
					col = 0;
					++row;
					++idx;
					continue;
					break;
			}
			this.colCount = Math.max(this.colCount, this.tiles[row].length);
			++idx;
			// Get object, if present.
			switch (levelText[idx]) {
				case " ":
					object = null;
					break;
				case "@":
					object = new Character(this, [row, col]);
					this.characters.add(object);
					break;
				case "X":
					object = new Crate(this, [row, col]);
					break;
				case "*":
					object = new IceBlock(this, [row, col]);
					break;
			}
			this.objects[row].add(object);
			++idx;
			++col;
		}
		this.xMargin = (X_RES - this.colCount * TILE_SIZE) / 2;
		this.yMargin = (Y_RES - this.rowCount * TILE_SIZE) / 2;
	}

	// Converts (row, col) to (x, y).
	function rowColToXY(row, col) {
		return [this.xMargin + col * TILE_SIZE, this.yMargin + row * TILE_SIZE];
	}

	// Converts (x, y) to (row, col).
	function xyToRowCol(x, y) {
		return [(y - this.yMargin) / TILE_SIZE, (x - this.xMargin) / TILE_SIZE];
	}

	// Gets the position adjacent to "position", towards "direction".
	function neighbor(position, direction) {
		switch (direction) {
			case Direction.UP:
				return [(position[0] - 1) % this.rowCount, position[1]];
				break;
			case Direction.DOWN:
				return [(position[0] + 1) % this.rowCount, position[1]];
				break;
			case Direction.LEFT:
				return [position[0], (position[1] - 1) % this.colCount];
				break;
			case Direction.RIGHT:
				return [position[0], (position[1] + 1) % this.colCount];
				break;
		}
	}

	// Pushes "object" towards "direction", along with anything in the way, if "strength" >= # of objects to push.
	function push(object, direction, strength = 2) {
		// Can't push anything with no strength.
		if (strength == 0) return false;

		// Get neighboring position.
		neighborPosition = this.neighbor(object.position, direction);

		// Push neighbor, if any.
		neighbor = this.objects[neighborPosition[0]][neighborPosition[1]];
		if (neighbor != null && !this.push(neighbor, direction, strength - 1)) {
			// Too much stuff in the way.
			return false;
		}

		// Try to push object.
		neighborTile = this.tiles[neighborPosition[0]][neighborPosition[1]];
		if (neighborTile == Tile.WALL) {
			return false;
		} else {
			// Move one.
			this.objects[object.position[0]][object.position[1]] = null;
			this.objects[neighborPosition[0]][neighborPosition[1]] = object;
			object.position = neighborPosition;
		}
		if (this.tiles[object.position[0]][object.position[1]] == Tile.ICE) {
			// Slide.
			this.push(object, direction, strength);
		}
		return true;
	}

	// Whether the current character can summon from the future at the given row-column position.
	function canSummonAt(position) {
		// Can't summon more than one future character from the current character instance.
		if (this.characters[this.characterIdx].returnPoint != null) {
			return false;
		}

		// Can't summon out of bounds.
		if (position[0] < 0 || position[0] >= this.rowCount || position[1] < 0 || position[1] >= this.colCount) {
			return false;
		}

		// Can't summon into certain tiles.
		switch (this.tiles[position[0]][position[1]]) {
			case Tile.WALL:
				return false;
				break;
			case Tile.STAIRS:
				return false;
				break;
			case Tile.HOLE:
				return false;
				break;
			default:
				break;
		}

		// Can't summon onto other objects.
		if (this.objects[position[0]][position[1]] != null) {
			return false;
		}

		return true;
	}

	// Summons the current character from the future at the given target position.
	function summonFromFuture(position) {
		if (!this.canSummonAt(position)) {
			return;
		}

		currentCharacter = this.characters[this.characterIdx];
		// Create future character.
		futureCharacter = new Character(this, position.clone());
		this.objects[position[0]][position[1]] = futureCharacter;
		// Add the new character after the current character and switch control to it.
		this.characters.insert(this.characterIdx + 1, futureCharacter);
		++this.characterIdx;
		// Create a return point where the future character came from.
		returnPoint = new ReturnPoint(this, position.clone(), 20, currentCharacter);
		// Set the current character as the character who needs to return to the return point.
		currentCharacter.returnPoint = returnPoint;
		// Andvance time.
		this.advanceTime();
		// Add the return point to the list after advancing time so it starts at max time.
		this.returnPoints.add(returnPoint);
	}

	// Advances time by one turn.
	function advanceTime() {
		for (i = 0; i < this.returnPoints.length; ++i) {
			returnPoint = this.returnPoints[i];
			character = returnPoint.character;
			position = returnPoint.position;
			--returnPoint.time;
			if (returnPoint.time == 0) {
				if (character.position[0] == position[0] && character.position[1] == position[1]) {
					// Remove character.
					for (j = 0; j < this.characters.length; ++j) {
						if (this.characters[j] == character) {
							this.objects[position[0]][position[1]] = null;
							this.characters.remove(j);
							if (this.characterIdx > j) {
								--this.characterIdx;
							}
							break;
						}
					}
					// Remove return point.
					this.returnPoints.remove(i);
					--i;
				} else {
					// Logical inconsistency!
					this.switchScene(new MainScene());
					return;
				}
			}
		}
		// Characters who wait look down.
		for (character : this.characters) {
			character.direction = Direction.DOWN;
		}
	}

	function update(inputManager, events) {
		if (inputManager.isKeyPressedThisFrame(KeyboardKey.ESCAPE)) {
			this.switchScene(new MainScene());
			return;
		}

		for (e : events) {
			if (e.type == EventType.MOUSE_PRESS) {
				// Summon.
				this.summonFromFuture(this.xyToRowCol(e.x, e.y));
			} else if (e.type == EventType.KEY && e.down) {
				direction = null;
				switch (e.key) {
					case KeyboardKey.Q:
						// Previous character.
						this.characterIdx = (this.characterIdx - 1) % this.characters.length;
						break;
					case KeyboardKey.E:
						// Next character.
						this.characterIdx = (this.characterIdx + 1) % this.characters.length;
						break;
					case KeyboardKey.SPACE:
						// Wait.
						this.advanceTime();
						break;
					// Movement commands.
					case KeyboardKey.UP:    direction = Direction.UP;    break;
					case KeyboardKey.DOWN:  direction = Direction.DOWN;  break;
					case KeyboardKey.LEFT:  direction = Direction.LEFT;  break;
					case KeyboardKey.RIGHT: direction = Direction.RIGHT; break;
					case KeyboardKey.W:     direction = Direction.UP;    break;
					case KeyboardKey.S:     direction = Direction.DOWN;  break;
					case KeyboardKey.A:     direction = Direction.LEFT;  break;
					case KeyboardKey.D:     direction = Direction.RIGHT; break;
					default:
						break;
				}
				if (direction != null) {
					// Try to move the current character.
					if (this.push(this.characters[this.characterIdx], direction)) {
						// If the character moved, advance time.
						this.advanceTime();
						// Update character's direction.
						this.characters[this.characterIdx].direction = direction;
					}
				}
			}
		}

		// Check for victory.
		if (this.characters.length == 1) {
			if (this.tiles[this.characters[0].position[0]][this.characters[0].position[1]] == Tile.STAIRS) {
				this.switchScene(new MainScene());
				return;
			}
		}

		// Save mouse position.
		this.mousePosition = inputManager.getMousePosition();
	}

	function render() {
		Graphics2D.Draw.fill(0, 0, 0);

		for (row = 0; row < this.rowCount; ++row) {
			for (col = 0; col < this.colCount; ++col) {
				// Draw tiles.
				xy = this.rowColToXY(row, col);
				switch (this.tiles[row][col]) {
					case Tile.WALL:
						image = Images.get("images/wall.png");
						break;
					case Tile.FLOOR:
						image = Images.get("images/floor.png");
						break;
					case Tile.ICE:
						image = Images.get("images/ice.png");
						break;
					case Tile.STAIRS:
						image = Images.get("images/stairs.png");
						break;
					case Tile.HOLE:
						image = Images.get("images/hole.png");
						break;
				}
				image.draw(xy[0], xy[1]);

				// Draw objects.
				object = this.objects[row][col];
				if (object != null) {
					object.draw();
					// Draw selector.
					if (this.characters.length > 1 && object == this.characters[this.characterIdx]) {
						Images.get("images/selector.png").draw(xy[0], xy[1]);
					}
				}
			}
		}

		// Draw return points.
		for (returnPoint : this.returnPoints) {
			returnPoint.draw();
		}

		// Draw mouse hover highlight.
		hoverPosition = this.xyToRowCol(this.mousePosition[0], this.mousePosition[1]);
		hoverRGB = this.canSummonAt(hoverPosition) ? [255, 255, 255] : [255, 0, 0];
		Graphics2D.Draw.rectangle
			( hoverPosition[1] * TILE_SIZE + 1, hoverPosition[0] * TILE_SIZE + 1
			, TILE_SIZE - 1, TILE_SIZE - 1
			, hoverRGB[0], hoverRGB[1], hoverRGB[2], 128
			);

		// Draw red outline (for debug).
		Graphics2D.Draw.line(0, 0, X_RES, 0, 1, 255, 0, 0);
		Graphics2D.Draw.line(0, 0, 0, Y_RES, 1, 255, 0, 0);
		Graphics2D.Draw.line(X_RES - 1, 0, X_RES - 1, Y_RES, 1, 255, 0, 0);
		Graphics2D.Draw.line(0, Y_RES - 1, X_RES, Y_RES - 1, 1, 255, 0, 0);
	}
}
